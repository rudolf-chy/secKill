## 秒杀系统

两个问题：并发读、并发写

关键点：“稳、准、快” 对应 “高性能、一致性、高可用“

两次MD5加密，一次用户端加密，防止被截获时破译密码，一次后端加密，防止数据库被盗，别人根据密文和盐进行反编译获取明文

分布式session：

session复制：

优点：无需修改代码，只需要修改tomcat配置

缺点：

1、session同步传输占用内网带宽

2、多台tomcat同步性能指数级下降

3、session占用内存，无法水平扩展

前端存储：

优点：不占用服务端内存

缺点：

1、存在安全风险

2、数据大小受cookie限制

3、占用外网带宽

Session粘滞

优点：

1、无需修改代码

2、服务端可以水平扩展

缺点：

1、增加新机器，会重新hash，导致重新登陆

2、应用重启，需要重新登陆

后端集中存储

优点：

1、安全

2、容易水平扩展

缺点：

1、增加复杂度

2、需要修改代码

登陆功能总结

最简单的登陆功能就是请求发到controller-service-mapper-mysql

每个类都进行健壮性校验太麻烦，使用validation注解来验证格式信息，而仅仅这样出现错误只会在后端报异常，所以我们在后端编写全局异常处理

之后是解决分布式session的问题，可以使用Spring session来解决，只需要部署一个redis加配置相关的信息，不需要修改源代码，这样就会将session信息保存在redis。还可以通过将用户的信息登陆到redis，让所有的主机通过redis来读取session的信息而不是从tomcat。

秒杀功能总结

准备4个表，商品表、订单表、秒杀商品表、秒杀订单表，为了方便后期的处理，因为有的时候可能正常价格与秒杀价格同时放出来

准备4个页面，商品列表页、商品详情页、订单详情页、秒杀失败页

关键点：后端给出状态码，前端通过状态码更新显示，动态倒计时的实现需要用到定时器，通过typ等于hidden的input来获取值，设置button的属性来实现秒杀时可以秒杀，其他时候无效。

QPS(Query Per Second) TPS(Transaction Per Second)

压测发现的问题：不需要等到秒杀时间就可以秒杀、超卖

优化方向：页面/对象缓存、页面静态化、静态资源优化、CDN优化

开启浏览器缓存，返回代码304，缓存静态页面

1、减库存用sql语句去处理，加判定大于0才去处理

2、对减库存结果进行判定，失败就不创建订单

3、创建唯一索引，解决一个用户多个商品的问题

4、使用redis优化一个用户重复抢购的查询

使用RabbitMQ实现异步处理请求

模式有Fanout、Direct、Topic、Headers

将对象转化为json字符串进行传输

利用redis进行预减操作

利用标记当没有库存的时候不去与redis进行交互

利用redis实现分布式锁

设置锁的过期时间，防止因为出现异常导致锁无法释放

为每个线程设置自己的value，每次删除前如果是自己设置的value就删除

使用lua脚本实现redis的原子操作

安全优化

1、隐藏接口

2、使用验证码隔离脚本，分散流量

3、接口限流

限流策略：

计数器：临界问题，浪费资源

漏桶（保护他人）：

水太大，直接废了，水太小，浪费资源

令牌桶（保护自己）：

有效应对爆发流量

ThreadLocal<>保存每个线程的私有数据

使用拦截器简化代码

项目框架搭建

1.SpringBoot环境搭建

2.集成Thymleaf，RespBean

3.MyBatis

分布式会话

1.用户登录

a.设计数据库

b.明文密码二次MD5加密

c.参数校验+全局处理异常

2.共享Session

a.SpringSession

b.Redis

功能开发

1.商品列表

2.商品详情

3.秒杀

4.订单详情

系统压测

1.JMeter

2.自定义变量模拟用户

3.JMeter命令行的使用

4.正式压测

a.商品列表

b.秒杀

页面优化

1.页面缓存+URL缓存+对象缓存

2.页面静态化，前后端分离

3.静态资源优化

4.CDN优化

接口优化

1.Redis预减库存

2.内存标记减少Redis的访问

3.RabbitMQ异步下单

a.SpringBoot整合RabbitMQ

b.交换机

安全优化

1.秒杀接口地址隐藏

2.算数验证码

3.接口防刷
